(class Object ^^global
  (init _
  )

  (method gene_type _
    ($invoke self 'get' '#type')
  )

  (method get prop-name
    ((@ prop-name))
  )

  (method set [prop-name value]
    ((@ prop-name) = value)
  )

  (method data _
    ($invoke self 'data')
  )

  (method first _
    (($invoke self 'data') .get 0)
  )

  (method call [name args...]
    ($invoke self name args...)
  )

  (method class _
    # if obj.is_a? Array
    #   context.get_member("Array")
    # elsif obj.is_a? Hash
    #   context.get_member("Hash")
    # elsif obj.is_a? Fixnum
    #   context.get_member("Int")
    # elsif obj.is_a? Gene::Lang::Aspect
    #   context.get_member("Aspect")
    # elsif obj.is_a? Gene::Lang::Class
    #   context.get_member("Class")
    # elsif obj.class == Gene::Lang::Object
    #   context.get_member("Object")
    # elsif obj.class == Gene::Lang::Context
    #   context.get_member("Context")
    # elsif obj.class == Gene::Lang::BreakValue
    #   context.get_member("BreakValue")
    # elsif obj.class == Gene::Lang::ReturnValue
    #   context.get_member("ReturnValue")
    # else
    #   obj.class
    # end
    (if ($invoke self 'is_a?' (get_native_class 'Array'))
      Array
    else-if ($invoke self 'is_a?' (get_native_class 'Hash'))
      Hash
    else-if ($invoke self 'is_a?' (get_native_class 'Gene::Lang::Class'))
      Class
    else-if ($invoke self 'is_a?' (get_native_class 'Gene::Lang::Function'))
      Function
    else
      ($invoke self 'instance_variable_get' '@klass')
    )
  )

  (method is klass
    ((.class) .is_sub_class klass)
  )
)

(class Context ^^global
  (method process_statements stmts
    # Gotcha: `return` is needed here in order to return any value as is to the caller.
    (return ($invoke self 'process_statements' stmts))
  )
)

(class Function ^^global
  (method bind target
    ($invoke self 'bind' target)
  )
)

(class Class ^^global
  (method parent_class _
    (@parent_class || Object)
  )

  # check whether I am klass or an ancestor of klass
  (method is_sub_class klass
    (if (self == klass)
      true
    else
      (if (self == Object)
        false
      else
        ((.parent_class) .is_sub_class klass)
      )
    )
  )
)

(class Aspect ^^global
  (method apply target
    ($invoke self 'apply' target)
  )
)

(class Throwable ^^global
  (prop message)
)

(class Exception extend Throwable
  ^^global
)

# Fatal errors
(class Error extend Throwable
  ^^global
)

(class Int ^^global
)

# Wrapper class for native arrays
(class Array ^^global
  (method class _
    ($invoke $context "get_member" "Array")
  )
  (method size _
    ($invoke self "size")
  )
  (method get i
    (if (i < (.size))
      ($invoke self '[]' i)
    )
  )
  (method push item
    ($invoke self 'push' item)
  )
  (method any f
    (for (var i 0) (i < (.size)) (i += 1)
      (var item (.get i))
      (if (f item i)
        (return true)
      )
    )
    false
  )
  (method each f
    (for (var i 0) (i < (.size)) (i += 1)
      (var item (.get i))
      (f item i)
    )
  )
  (method select f
    (var result [])
    (for (var i 0) (i < (.size)) (i += 1)
      (var item (.get i))
      # TODO:
    )
    result
  )
  (method flatten _
    (var result [])
    (.each
      (fnx item
        (if (($invoke ($invoke item 'class') 'name') == 'Gene::Lang::Array')
          (var child-array (item .flatten))
          (child-array .each
            (fnx item ($invoke result '<<' item))
          )
        else
          ($invoke result '<<' item)
        )
      )
    )
    result
  )
)

(class Hash ^^global
  (method size _
    ($invoke self "size")
  )
)

(class String ^^global
  (method + args...
    ($invoke $self '<<' args)
  )
)

(class BreakValue ^^global
)

(class ReturnValue ^^global
)

(class File ^^global
)

(fn get_native_class name
  ^^global
  ($invoke ($invoke '' 'class') 'const_get' name)
)

(fn if-not [cond stmts...]
  ^^global
  (if ($caller-context .process_statements cond)
    _
  else
    # Gotcha: `return` is needed here in order to return any value as is to the caller.
    (return ($caller-context .process_statements stmts))
  )
)

(fn for [init cond update stmts...]
  ^^global
  ^!inherit-scope ^!eval-arguments
  # Do not inherit scope from where it's defined in: equivalent to ^!inherit-scope
  # Args are not evaluated before passed in: equivalent to ^!eval-arguments
  #
  # After evaluation, ReturnValue are returned as is, BreakValue are unwrapped and returned
  ($caller-context .process_statements init)
  (loop
    # check condition and break if false
    (var cond-result ($caller-context .process_statements cond))
    (if-not cond-result
      return
    )

    # execuate statements
    (var result ($caller-context .process_statements stmts))
    # check result
    (if (($invoke ($invoke result 'class') 'name') == 'Gene::Lang::BreakValue')
      return
    )
    (if (($invoke ($invoke result 'class') 'name') == 'Gene::Lang::ReturnValue')
      (return result)
    )

    # update
    ($caller-context .process_statements update)
  )
)
