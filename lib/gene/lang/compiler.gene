(fn compile data...
  ^^global
  (compile_stmts data)
)

(fn compile_ data
  (if (data .is Int)
    data
  else_if (data .is Object)
    (if ((data .gene_type) == :var)
      (compile_var data)
    else_if ((data .gene_type) == :fn)
      (compile_fn data)
    else
      "TODO"
    )
  else
    data
  )
)

(fn compile_stmts data
  ((data .map
    (fnx item
      (var s (compile_ item))
      ('' s (if (s !~ #/}\s*$/) ';') "\n")
    )
  ) .join)
)

(fn compile_var data
  ("var " (data .get 0)
    (do
      (var value (data .get 1))
      (if (value != undefined)
        (" = " (compile_ value))
      )
    )
  )
)

(fn compile_fn data
  (var args  (data .get 2))
  (var stmts (data .get 2))
  ("fn " (data .get 0)
    "("
    ") {\n"
    "}"
  )
)

# DEPRECATED
(class Base
  (method var [name value]
    (new Variable name value)
  )

  (method ref name
    (new Reference name)
  )

  (method new expr
    (new New expr)
  )

  (method fn [name args callback]
    (new Function name args callback)
  )

  (method fnx [args callback]
    # (new Function '' args callback)
  )

  (method fnxx callback
    (new Function '' _ callback)
  )

  (method for [init cond update stmts]
    (new For init cond update stmts)
  )

  (method chain exprs...
    (new ChainedInvocation exprs)
  )

  (method invoke [target args...]
    (new Invocation target args)
  )

  (method binary [left op right]
    (new BinaryExpr left op right)
  )

  (method assign [target value]
    (new Assignment target value)
  )

  (method if_ [cond logic else_logic]
    (new If cond logic else_logic)
  )

  (method ret value
    (new Return value)
  )

  (method break_ _
    (new Break)
  )

  (method obj data
    (new Obj data)
  )

  (method to_s _
    "// Base: should not reach here"
  )
)

(class Root extend Base
  (init callback
    (@stmts = [])
    (if callback (call callback self))
  )

  (method to_s _
    (var result '')
    (@stmts .each (fnx stmt
      (result += ((stmt .to_s) + '\n'))
    ))
    result
  )
)

(class Variable extend Base
  (prop name)
  (prop value)

  (init [name value]
    (@name  = name)
    (@value = value)
  )

  (method to_s _
    ("var " @name (if @value (" = " @value)) ";")
  )
)

(class Function extend Base
  (prop name)
  (prop args)
  (prop stmts)

  (init [name args callback]
    (@name = name)
    (@args = args)
    (@stmts = [])
    (if callback (call callback self))
  )

  (method to_s _
    ('function '
      (if @name then (@name .to_s) else '')
      "(" (@args .map (fnx arg (arg .to_s))) "){\n"
      "}\n"
    )
  )
)

(class If extend Base
  (prop cond)
  (prop logic)
  (prop else_ifs)
  (prop else_logic)

  (init [cond logic else_logic]
    (@cond       = cond)
    (@logic      = logic)
    (@else_ifs   = [])
    (@else_logic = else_logic)
  )

  (method to_s _
    (var result "if (")
    (result += ") {\n")
    (result += "}\n")
    result
  )
)

(class For extend Base
  (prop init)
  (prop cond)
  (prop update)
  (prop stmts)

  (init [init cond update stmts]
    (@init   = init)
    (@cond   = cond)
    (@update = update)
    (@stmts  = stmts)
  )

  (method to_s _
    (var result "for (")
    (result += ") {\n")
    (result += "}\n")
    result
  )
)

(class Reference extend Base
  (prop name)

  (init name
    (@name = name)
  )

  (method to_s _
    ("" @name)
  )
)

(class Assignment extend Base
  (prop target)
  (prop value)

  (init [target value]
    (@target = target)
    (@value  = value)
  )

  (method to_s _
    ('' (@target .to_s) ' = ' (@value .to_s))
  )
)

(class Invocation extend Base
  (prop target)
  (prop args)

  (init [target args]
    (@target = target)
    (@args   = args)
  )

  (method to_s _
    (var result "")
    (if (@target .is Function)
      (result += ("(" (@target .to_s) ")"))
    else
      (result += (@target .to_s))
    )
    (result += "(")
    (result += ")")
    result
  )
)

(class ChainedInvocation extend Base
  (prop invocations)

  (init invocations
    (@invocations = invocations)
  )

  (method to_s _
    (@invocations .join '.')
  )
)