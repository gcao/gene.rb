(fn compile data...
  ^^global
  (compile_stmts data)
)

(var BINARY_IDS (:: [+ - * / < <= > >= == != ++ --]))

(fn compile_ data
  (if (data .is Int Symbol)
    data
  else_if (data .is Object)
    (if ((data .type) == :var)
      (compile_var data)
    else_if ((data .type) == :if)
      (compile_if data)
    else_if ((data .type) == :fn)
      (compile_fn data)
    else_if ((data .type) == :fnx)
      (compile_fnx data)
    else_if ((data .type) == :new)
      (compile_new data)
    else_if ((data .type) == :for)
      (compile_for data)
    else_if (BINARY_IDS .include (data .get 0))
      (compile_binary data)
    else_if ((data .get 0) == :?)
      (compile_ternary data)
    else_if ([:@] .include (data .get 0))
      (match (first _ second) data)
      ("" first "[" second "]")
    else_if ([:! :return] .include (data .type))
      ("" (data .type) " " (compile_ (data .get 0)))
    else
      "TODO"
    )
  else
    ("TODO: (compile_ " ($inspect self 'inspect') ")")
  )
)

(fn compile_stmts data
  ((data .map
    (fnx item
      (var s (compile_ item))
      ('' s (if (s !~ #/}\s*$/) ';') "\n")
    )
  ) .join)
)

(fn compile_var data
  ("var " (data .get 0)
    (do
      (var value (data .get 1))
      (if (value != undefined)
        (" = " (compile_ value))
      )
    )
  )
)

(fn compile_fn data
  (match [name args stmts...] data)
  ("function " name
    "(" (args .join ", ") ") {\n"
      (compile_stmts stmts)
    "}"
  )
)

(fn compile_fnx data
  (match [args stmts...] data)
  ("function(" (args .join ", ") ") {\n"
    (compile_stmts stmts)
    "}"
  )
)

(fn compile_new data
  (match [type args...] data)
  ("new " (compile_ type) "(" (args .join ", ") ")")
)

(fn compile_binary data
  (match (left op right) data)
  ("(" (compile_ left) " " op
    (if right
      (" " (compile_ right))
    )
  ")")
)

(fn compile_ternary data
  (match (cond _ first second) data)
  ("(" (compile_ cond) " ? " (compile_ first) " : " (compile_ second) ")")
)

(fn compile_if data
  (var if_cond (data .get 0))
  (var if_stmts [])
  (var else_ifs [])
  (var else_stmts [])

  (var state :if)
  (var cond)
  (var stmts [])
  (for (var i 1) (i < (data .size)) (i += 1)
    (var item (data .get i))

    (if (item == :else_if)
      (if (state == :else_if)
        (else_ifs .push [cond stmts])
      )
      (state = :else_if)
      (i += 1)
      (cond  = (data .get i))
      (stmts = [])

    else_if (item == :else)
      (if (state == :else_if)
        (else_ifs .push [cond stmts])
      )
      (state = :else)

    else
      (if (state == :if)
        (if_stmts .push item)
      else_if (state == :else_if)
        (stmts .push item)
      else_if (state == :else)
        (else_stmts .push item)
      )
    )
  )

  ("if (" (compile_ if_cond) ") {\n"
    (compile_stmts if_stmts)
    (if ((else_ifs .size) > 0)
      ((else_ifs .map
        (fnx pair
          (match [cond stmts] pair)
          ("} else if (" (compile_ cond) ") {\n"
            (compile_stmts stmts)
          )
        )
      ) .join)
    )
    (if ((else_stmts .size) > 0)
      ("} else {\n"
        (compile_stmts else_stmts)
      )
    )
   "}"
  )
)

(fn compile_for data
  (match [init cond update stmts...] data)
  ("for ("
    (compile_ init) "; "
    (compile_ cond) "; "
    (compile_ update) ") {\n"
      (compile_stmts stmts)
    "}"
  )
)

# DEPRECATED
(class Base
  (method to_s _
    "Base.to_s: should not reach here"
  )
)

(class Root extend Base
  (init callback
    (@stmts = [])
    (if callback (call callback self))
  )

  (method to_s _
    ("" @stmts)
  )
)

(class Stmts extend Base
  (init stmts
  )

  (method to_s _
    ((@stmts .map (fnx stmt ("" stmt ";\n"))) .join)
  )
)

(class Variable extend Base
  (prop name)
  (prop value)

  (init [name value]
    (@name  = name)
    (@value = value)
  )

  (method to_s _
    ("var " @name (if @value (" = " @value)) ";")
  )
)

(class Function extend Base
  (prop name)
  (prop args)
  (prop stmts)

  (init [name args callback]
    (@name = name)
    (@args = args)
    (@stmts = [])
    (if callback (call callback self))
  )

  (method to_s _
    ('function '
      (if @name then (@name .to_s) else '')
      "(" (@args .map (fnx arg (arg .to_s))) "){\n"
      "}\n"
    )
  )
)

(class If extend Base
  (prop cond)
  (prop logic)
  (prop else_ifs)
  (prop else_logic)

  (init [cond logic else_logic]
    (@cond       = cond)
    (@logic      = logic)
    (@else_ifs   = [])
    (@else_logic = else_logic)
  )

  (method to_s _
    (var result "if (")
    (result += ") {\n")
    (result += "}\n")
    result
  )
)

(class For extend Base
  (prop init)
  (prop cond)
  (prop update)
  (prop stmts)

  (init [init cond update stmts]
    (@init   = init)
    (@cond   = cond)
    (@update = update)
    (@stmts  = stmts)
  )

  (method to_s _
    (var result "for (")
    (result += ") {\n")
    (result += "}\n")
    result
  )
)

(class Reference extend Base
  (prop name)

  (init name
    (@name = name)
  )

  (method to_s _
    ("" @name)
  )
)

(class Assignment extend Base
  (prop target)
  (prop value)

  (init [target value]
    (@target = target)
    (@value  = value)
  )

  (method to_s _
    ('' (@target .to_s) ' = ' (@value .to_s))
  )
)

(class Invocation extend Base
  (prop target)
  (prop args)

  (init [target args]
    (@target = target)
    (@args   = args)
  )

  (method to_s _
    (var result "")
    (if (@target .is Function)
      (result += ("(" (@target .to_s) ")"))
    else
      (result += (@target .to_s))
    )
    (result += "(")
    (result += ")")
    result
  )
)

(class ChainedInvocation extend Base
  (prop invocations)

  (init invocations
    (@invocations = invocations)
  )

  (method to_s _
    (@invocations .join '.')
  )
)