(import process_if from './utils')

(var BINARY_IDS (:: [= + - * / < <= > >= == != ++ --]))

(fn compile code...
  ^^global

  # Empty code becomes [Stream] for some reason
  (if ((code .get 0) .is Stream)
    (code = (code .get 0))
  )
  (gene2js_
    ^^#render_args
    (var $root_context ($application . (create_root_context <-)))
    ((fnx $context
      (var $result)
      (%expand
        (code .map (fnx item
          (:$result = (%compile_ item))
        ))
      )
      (return $result)
    ) <- $root_context)
  )
)

(fn gene2js_ code...
  ^!eval_arguments

  (var result
    (gene2js
      code...
    )
  )
  result
)

(fn compile_ data
  (if (data .is Boolean Int)
    data
  else_if (data .is Symbol)
    (compile_symbol data)
  else_if (data .is Undefined)
    undefined
  else_if (data .is Object)
    (if ((data .type) == :var)
      (compile_var data)
    else_if ((data .type) == :if)
      (compile_if data)
    else_if ((data .type) == :for)
      (compile_for data)
    else_if ((data .type) == :loop)
      (compile_loop data)
    else_if ((data .type) == :fn)
      (compile_fn data)
    else_if ((data .type) == :assert)
      (compile_assert data)
    else_if (BINARY_IDS .include (data .get 0))
      (compile_binary data)
    else
      (compile_invocation data)
    )
  )
)

(fn compile_symbol data
  (::
    (($context .get_member) <- (%= (data .to_s)))
  )
)

# TODO: Maybe we can create a function 'macro' that works like this
# (macro compile_var data
#   (($context . var) <-
#     (%= ((data .get 0) .to_s))
#     (%data .get 1)
#   )
# )
(fn compile_var data
  (::
    (($context . var) <-
      (%= ((data .get 0) .to_s))
      (%data .get 1)
    )
  )
)

(fn compile_assert data
  (match [cond mesg] data)
  (::
    ((Gene .assert) <- (%compile_ cond) %mesg)
  )
)

(fn compile_binary data
  (match (left op right) data)
  (::
    ((%compile_ left) %op (%compile_ right))
  )
)

(fn compile_fn data
  (match [name args stmts...] data)
  (::
    (($context .fn) <-
      (%= (name .to_s))
      (%args .map (fnx arg (arg .to_s)))
      (fnx $context
        (var $result)
        (%expand (compile_stmts stmts))
        (return $result)
      )
    )
  )
)

(fn compile_stmts [^^assign_to_result stmts]
  (stmts .map (fnx [item i]
    (if ((! assign_to_result) || (i < ((stmts .size) - 1)))
      (compile_ item)
    else
      (:$result = (%compile_ item))
    )
  ))
)

(fn compile_invocation data
  (match (name args...) data)
  (::
    (((($context .get_member) <- (%= (name .to_s)))
      .invoke) <-
      (%expand (args .map (fnx arg (compile_ arg))))
    )
  )
)

# Compilation depends on a few scenarios:
# Is top level statement in function?
#   If yes, compiles to regular if statement
#   If is last statement, make sure $result is assigned
# Must compile to an expression?
#   Comiles to ternary expression and wrap up with ()
#   All code inside must be compiled as expression
# Has 'return' inside
#   $result must be assigned
#   Add a statement to check whether result is a return
(fn compile_if data
  (var processed (process_if data))
  (::
    ((%processed .get 'cond') ?
      (%group_stmts (processed .get 'then'))
      (%group_stmts (processed .get 'else'))
    )
  )
)

# Compilation depends on a few scenarios:
# Is top level statement in function?
#   If yes, compiles to regular "while(true){}" statement
#   If no, compiles to expression
# Must compile to an expression?
#   Compiles to a function that shares current context
# Has 'return' inside
#   $result must be assigned
#   Add a statement to check whether result is a return
(fn compile_loop data
)

# Compilation depends on a few scenarios:
# Is top level statement in function?
# Must compile to an expression?
# Has 'return' inside
(fn compile_for data
  (match [init cond update body...] data)
  (::
    ((Gene .for) <- (fnx $context
      (for (%compile_ init) (%compile_ cond) (%compile_ update)
        (%expand (compile_stmts ^!assign_to_result body))
      )
    ))
  )
)

(fn group_stmts stmts
  (if ((stmts .size) < 2)
    (stmts .get 0)
  else
    (var result (new Object []))
    (result .set '#type' (stmts .get 0))
    (for (var i 1) (i < (stmts .size)) (i += 1)
      ((result .data) .push :~)
      ((result .data) .push (stmts .get i))
    )
    result
  )
)